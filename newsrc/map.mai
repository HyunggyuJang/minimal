(* The Map module is directly translated from OCaml *)

(* $Id: map.mai,v 1.1 1997/10/30 09:25:35 garrigue Exp $ *)

type ('a,'b) t
    (* The type of maps from type ['a] to type ['b]. *)
val empty: ('a -> 'a -> int) -> ('a,'b) t
    (* Build the empty map from a comparison function. *)
val add: 'a -> 'b -> ('a,'b) t -> ('a,'b) t
    (* [add x y m] returns a map containing the same bindings as
       [m], plus a binding of [x] to [y]. If [x] was already bound
       in [m], its previous binding disappears. *)
val find: 'a -> ('a,'b) t -> 'b
    (* [find x m] returns the current binding of [x] in [m],
       or raises [Not_found] if no such binding exists. *)
val remove: 'a -> ('a,'b) t -> ('a,'b) t
    (* [remove x m] returns a map containing the same bindings as
       [m], except for [x] which is unbound in the returned map. *)
val iter: ('a -> 'b -> 'c) -> ('a,'b) t -> unit
    (* [iter f m] applies [f] to all bindings in map [m],
       discarding the results.
       [f] receives the key as first argument, and the associated value
       as second argument. The order in which the bindings are passed to
       [f] is unspecified. Only current bindings are presented to [f]:
       bindings hidden by more recent bindings are not passed to [f]. *)
val fold: ('a -> 'b -> 'c -> 'c) -> ('a,'b) t -> 'c -> 'c
    (* [fold f m a] computes [(f kN dN ... (f k1 d1 a)...)],
       where [k1 ... kN] are the keys of all bindings in [m],
       and [d1 ... dN] are the associated data.
       The order in which the bindings are presented to [f] is
       not specified. *)
