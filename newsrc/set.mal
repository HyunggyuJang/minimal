(* The Set module is directly translated from OCaml *)

(* $Id: set.mal,v 1.1 1997/10/31 02:56:10 garrigue Exp $ *)

type 'a t = { compare: 'a -> 'a -> int , set: 'a tree }
and 'a tree = Empty | Node of 'a tree * 'a * 'a tree * int

    (* Sets are represented by balanced binary trees (the heights of the
       children differ by at most 2 *)

fun height t =
  case t of
    Empty => 0
  | Node(_, _, _, h) => h
  end

    (* Creates a new node of left son l, value x and right son r.
       l and r must be balanced and | height l - height r | <= 2.
       Inline expansion of height for better speed. *)

fun create l x r =
  begin
    val hl = case l of Empty => 0 | Node(_,_,_,h) => h end;
    val hr = case r of Empty => 0 | Node(_,_,_,h) => h end;
    Node(l, x, r, (if hl >= hr then hl + 1 else hr + 1))
  end

    (* Same as create, but performs one step of rebalancing if necessary.
       Assumes l and r balanced.
       Inline expansion of create for better speed in the most frequent case
       where no rebalancing is required. *)

fun bal l x r =
  begin
    val hl = case l of Empty => 0 | Node(_,_,_,h) => h end;
    val hr = case r of Empty => 0 | Node(_,_,_,h) => h end;
    if hl > hr + 2 then
      case l of
        Empty => invalid_arg "Set.bal"
      | Node(ll, lv, lr, _) =>
          if height ll >= height lr then
            create ll lv (create lr x r)
          else
            case lr of
              Empty => invalid_arg "Set.bal"
            | Node(lrl, lrv, lrr, _)=>
                create (create ll lv lrl) lrv (create lrr x r)
            end
      end
    else if hr > hl + 2 then
      case r of
        Empty => invalid_arg "Set.bal"
      | Node(rl, rv, rr, _) =>
          if height rr >= height rl then
            create (create l x rl) rv rr
          else
            case rl of
              Empty => invalid_arg "Set.bal"
            | Node(rll, rlv, rlr, _) =>
                create (create l x rll) rlv (create rlr rv rr)
            end
      end
    else Node(l, x, r, (if hl >= hr then hl + 1 else hr + 1))
  end

    (* Same as bal, but repeat rebalancing until the final result
       is balanced. *)

fun join l x r =
  case bal l x r of
    Empty => invalid_arg "Set.join"
  | Node(l', x', r', _) as t' =>
      val d = height l' - height r';
      if d < -2 or d > 2 then join l' x' r' else t'
  end

    (* Merge two trees l and r into one.
       All elements of l must precede the elements of r.
       Assumes | height l - height r | <= 2. *)

fun merge t1 t2 =
  case (t1, t2) of
    (Empty, t) => t
  | (t, Empty) => t
  | (Node(l1, v1, r1, h1), Node(l2, v2, r2, h2)) =>
      bal l1 v1 (bal (merge r1 l2) v2 r2)
  end

    (* Same as merge, but does not assume anything about l and r. *)

fun concat t1 t2 =
  case (t1, t2) of
    (Empty, t) => t
  | (t, Empty) => t
  | (Node(l1, v1, r1, h1), Node(l2, v2, r2, h2)) =>
      join l1 v1 (join (concat r1 l2) v2 r2)
  end

    (* Splitting *)

fun split f t =
  case t of
    Empty =>
      (Empty, None, Empty)
  | Node(l, v, r, _) =>
      val c = f v;
      if c = 0 then (l, Some v, r)
      else if c < 0 then
	begin
	  val (ll, vl, rl) = split f l;
	  (ll, vl, join rl v r)
	end
      else
	begin
          val (lr, vr, rr) = split f r;
	  (join l v lr, vr, rr)
	end
  end

    (* Implementation of the set operations *)

fun empty cmp = {compare=cmp, set=Empty}

fun is_empty s = (s.set = Empty)

fun mem x s =
  begin
    val test = s.compare x;
    fun mem t =
      case t of
        Empty => false
      | Node(l, v, r, _) =>
          val c = test v;
          if c = 0 then true else
          if c < 0 then mem l else mem r
      end;
    mem s.set
  end

fun add x s =
  begin
    val test = s.compare x;
    fun add t =
      case t of
	Empty => Node(Empty, x, Empty, 1)
      | Node(l, v, r, _) =>
          val c = test v;
          if c = 0 then t else
          if c < 0 then bal (add l) v r else bal l v (add r)
      end;
    s.{set = add s.set}
  end

fun remove x s =
  begin
    val test = s.compare x;
    fun remove t =
      case t of
        Empty => Empty
      | Node(l, v, r, _) =>
          val c = test v;
          if c = 0 then merge l r else
          if c < 0 then bal (remove l) v r else bal l v (remove r)
      end;
    s.{set = remove s.set}
  end

fun union s1 s2 =
  begin
    fun union t1 t2 =
      case (t1, t2) of
	(Empty, t2) => t2
      | (t1, Empty) => t1
      | (Node(l1, v1, r1, _), t2) =>
	  val (l2, _, r2) = split (s1.compare v1) t2;
	  join (union l1 l2) v1 (union r1 r2)
      end;
    s1.{set = union s1.set s2.set}
  end

fun inter s1 s2 =
  begin
    fun inter t1 t2 =
      case (t1, t2) of
        (Empty, t2) => Empty
      | (t1, Empty) => Empty
      | (Node(l1, v1, r1, _), t2) =>
          case split (s1.compare v1) t2 of
            (l2, None, r2) =>
              concat (inter l1 l2) (inter r1 r2)
          | (l2, Some _, r2) =>
              join (inter l1 l2) v1 (inter r1 r2)
	  end
      end;
    s1.{set = inter s1.set s2.set}
  end

fun diff s1 s2 =
  begin
    fun diff t1 t2 =
      case (t1, t2) of
        (Empty, t2) => Empty
      | (t1, Empty) => t1
      | (Node(l1, v1, r1, _), t2) =>
          case split (s1.compare v1) t2 of
            (l2, None, r2) =>
              join (diff l1 l2) v1 (diff r1 r2)
          | (l2, Some _, r2) =>
              concat (diff l1 l2) (diff r1 r2)
	  end
      end;
    s1.{set = diff s1.set s2.set}
  end

fun compare_aux cmp l1 l2 =
  case (l1, l2) of
    ([], []) => 0
  | ([], _)  => -1
  | (_, []) => 1
  | (Empty :: t1, Empty :: t2) =>
      compare_aux cmp t1 t2
  | (Node(Empty, v1, r1, _) :: t1, Node(Empty, v2, r2, _) :: t2) =>
      val c = cmp v1 v2;
      if c <> 0 then c else compare_aux cmp (r1::t1) (r2::t2)
  | (Node(l1, v1, r1, _) :: t1, t2) =>
      compare_aux cmp (l1 :: Node(Empty, v1, r1, 0) :: t1) t2
  | (t1, Node(l2, v2, r2, _) :: t2) =>
      compare_aux cmp t1 (l2 :: Node(Empty, v2, r2, 0) :: t2)
  end

fun compare s1 s2 =
  compare_aux s1.compare [s1.set] [s2.set]

fun equal s1 s2 = (compare s1 s2 = 0)

fun iter f s =
  begin
    fun iter t =
      case t of
        Empty => ()
      | Node(l, v, r, _) => iter l; f v; iter r
      end;
    iter s.set
  end

fun fold f s accu =
  begin
    fun fold s accu =
      case s of
        Empty => accu
      | Node(l, v, r, _) => fold l (f v (fold r accu))
      end;
    fold s.set accu
  end

fun cardinal_aux t =
  case t of Empty => 0
  | Node (l,_,r,_) => cardinal_aux l + cardinal_aux r + 1
  end
fun cardinal s = cardinal_aux s.set

fun elements_aux accu t =
  case t of
    Empty => accu
  | Node(l, v, r, _) => elements_aux (v :: elements_aux accu r) l
  end

fun elements s = elements_aux [] s.set

fun choose s =
  case s.set of
    Empty => raise Not_found
  | Node(l, v, r, _) => v
  end
