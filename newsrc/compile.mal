(* $Id: compile.mal,v 1.5 1997/11/25 07:39:05 garrigue Exp $ *)

open Common
open Define
open Untyped

exception Match_error of string

type var_alloc =
    { mutable size: int,
      mutable table: (ident, int) Map.t,
      mutable defined: ident Set.t,
      mutable needed: ident Set.t }

val empty_set = Set.empty compare_id
val empty_table = Map.empty compare_id

fun empty_alloc () =
  { size = 0, table = empty_table,
    defined = empty_set, needed = empty_set }
fun new_alloc alloc =
  { size = 0, table = empty_table,
    defined = alloc.defined, needed = empty_set }

fun add_alloc alloc id =
  begin
    val index = alloc.size;
    alloc.defined <- Set.add id alloc.defined;
    alloc.table <- Map.add id index alloc.table;
    alloc.size <- index + 1;
    index
  end

fun find_alloc alloc id =
  if Set.mem id alloc.defined then
    begin Map.find id alloc.table
    handle Not_found =>
      alloc.needed <- Set.add id alloc.needed;
      add_alloc alloc id
    end
  else
    raise Not_found
  
fun repr_constant c =
  case c of
    Cint n => Obj.repr n
  | Cchar c => Obj.repr c
  | Cfloat x => Obj.repr x
  end

type pattern =
    CPid of int
  | CPint of int
  | CPconst of Obj.t
  | CPblock of int * pattern array
  | CPany

fun pattern alloc upat =
  case upat of
    UPid id =>
      val n = add_alloc alloc id;
      CPid n
  | UPconst (Cfloat x) =>
      CPconst (Obj.repr x)
  | UPconst c =>
      CPint (Obj.magic (repr_constant c))
  | UPblock (tag, []) =>
      CPint tag
  | UPblock (tag, l) =>
      val cv = Array.map (pattern alloc) (Array.of_list l);
      begin
	val obj = Obj.new_block tag (Array.length cv);
	for i = 0 to Array.length cv - 1 do begin
	  val field =
	    case cv.[i] of
	      CPint x => Obj.repr x
	    | CPconst obj => obj
	    | _ => raise Not_found
	    end;
	  Obj.set_field obj i field
	end;
	CPconst obj
      handle
	Not_found => CPblock (tag, cv)
      end
  | UPany =>
      CPany
  end

(* from now on we need fast vector accesses *)
(* #open"fvect";; *)
(* #open"obj";; *)

fun matching alloc exn pat =
  begin
    val cpat = pattern alloc pat;
    fun match_rec cpat =
      case cpat of
	CPany =>
	  (fn _ _ => ())
      | CPid n =>
	  (fn env obj => Array.unsafe_set env n obj)
      | CPint x =>
	  (fn _ obj => if x != (Obj.magic obj) then raise exn)
      | CPconst x =>
	  (fn _ obj => if x <> obj then raise exn)
      | CPblock (tag, arr) =>
	  (fn env obj =>
	    begin
	      if not (Obj.is_block obj) or Obj.tag obj <> tag then raise exn;
	      for i = 0 to Array.length arr - 1 do
		match_rec (Array.unsafe_get arr i)
		  env
		  (Array.unsafe_get (Obj.magic obj) i)
	    end)
      end;
    match_rec cpat
  end

exception Match_failure

fun return obj env = obj

fun command alloc ue =
  case ue of
    UEexpr e =>
      val code = expression alloc e;
      (fn env => begin code env; () end)
  | UEval (UPid id, e, err) =>
      val code = expression alloc e;
      val i = add_alloc alloc id;
      (fn env => Array.unsafe_set env i (code env))
  | UEval (pat, e, err) =>
      val mtc = matching alloc (Match_error err) pat
      and code = expression alloc e;
      (fn env => mtc env (code env))
  | UEfun l =>
      val offset = alloc.size;
      val v = Array.of_list l;
      (* Allocate locally only if not defined globally *)
      begin
	val orefs = Array.map (fn (id,e) => Map.find id global.env) v;
	val codes = Array.map (fn (id,e) => expression alloc e) v
	and last = Array.length v -  1;
	(fn env =>
	  for i = 0 to last do
	    (Array.unsafe_get orefs i).contents
	      <- Array.unsafe_get codes i env)
      handle
	Not_found =>
	  Array.iter (fn (id,e) => begin add_alloc alloc id; () end) v;
	  val codes = Array.map (fn (id,e) => expression alloc e) v
	  and last = Array.length v -  1;
	  (fn env =>
	    for i = 0 to last do
	      Array.unsafe_set env (i+offset)
		(Array.unsafe_get codes i env))
      end
  | UEvar (id, e) =>
      val code = expression alloc e;
      val i = add_alloc alloc id;
      (fn env => Array.unsafe_set env i (code env))
  end

and expression alloc ue =
  case ue of
    UEid id =>
      begin
	val i = find_alloc alloc id;
	(fn env => Array.unsafe_get env i)
      handle
	Not_found =>
	  begin
	    val oref = Map.find id global.env;
	    (fn env => !oref)
	  handle
	    Not_found => failwith (id.name ^ " not found")
	  end
      end
  | UEconst c => return (repr_constant c)
  | UEblock (tag, []) => return (Obj.repr tag)
  | UEblock (tag, l) =>
      val codes = Array.map (expression alloc) (Array.of_list l);
      val size = Array.length codes;
      (fn env =>
	begin
	  val obj = Obj.new_block tag size;
	  for i = 0 to pred(size) do
	    Obj.set_field obj i (Array.unsafe_get codes i env);
	  obj
	end)
  | UEapply (UEid{name="&"|"or" as op}, [e1,e2]) =>
      val code1 = expression alloc e1
      and code2 = expression alloc e2;
      if op = "&" then
	(fn env => Obj.repr(Obj.magic(code1 env) & Obj.magic(code2 env)))
      else
	(fn env => Obj.repr(Obj.magic(code1 env) or Obj.magic(code2 env)))
  | UEapply (e, [e1]) =>
      val code = expression alloc e
      and code1 = expression alloc e1;
      (fn env => (Obj.magic (code env)) (code1 env))
  | UEapply (e, [e1, e2]) =>
      val code = expression alloc e
      and code1 = expression alloc e1
      and code2 = expression alloc e2;
      (fn env => (Obj.magic (code env)) (code1 env) (code2 env))
  | UEapply (e, l) =>
      val codes = List.map (expression alloc) l
      and code = expression alloc e;
      fun apply env obj l =
	case l of
	  [] => obj
	| code :: l => apply env ((Obj.magic obj) (code env)) l
	end;
      (fn env => apply env (code env) codes)
  | UEfunct (ids, e) =>
      val alloc' = new_alloc alloc;
      List.iter (fn id => begin add_alloc alloc' id; () end) ids;
      val code = expression alloc' e;
      val needed = Array.of_list (Set.elements alloc'.needed);
      val source =  Array.map (find_alloc alloc) needed
      and dest = Array.map (find_alloc alloc') needed
      and last_copy = Array.length needed - 1
      and last_id = List.length ids - 1
      and size = alloc'.size;
      if last_id = 0 then
	if last_copy = -1 then
	  (Obj.magic
	   (fn env x =>
	     begin
	       val new_env = (Obj.magic (Obj.new_block 0 size) : Obj.t array);
	       Array.unsafe_set new_env 0 x;
	       code new_env
	     end)
	   : Obj.t array -> Obj.t)
	else
	  (Obj.magic
	     (fn env x =>
	       begin
		 val new_env =
		   (Obj.magic (Obj.new_block 0 size) : Obj.t array);
		 Array.unsafe_set new_env 0 x;
		 for i = 0 to last_copy do
		   Array.unsafe_set new_env (Array.unsafe_get dest i)
		     (Array.unsafe_get env (Array.unsafe_get source i));
		 code new_env
	       end)
	   : Obj.t array -> Obj.t)
      else begin
	val pred_id = pred (last_id);
	fun copy_arg n l env =
	  if n = 0 then
	    Array.unsafe_set env 0 l
	  else begin
	    Array.unsafe_set env n (Obj.field l 0);
	    copy_arg (pred n) (Obj.field l 1) env
	  end;
	val code =
	  if last_copy = -1 then
	    (Obj.magic
	       (fn env l x =>
		 begin
		   val new_env =
		     (Obj.magic (Obj.new_block 0 size) : Obj.t array);
		   Array.unsafe_set new_env last_id x;
		   copy_arg pred_id l new_env;
		   code new_env
		 end)
	     : Obj.t array -> Obj.t -> Obj.t)
	  else
	    (Obj.magic
	       (fn env l x =>
		 begin
		   val new_env =
		     (Obj.magic (Obj.new_block 0 size) : Obj.t array);
		   Array.unsafe_set new_env last_id x;
		   copy_arg pred_id l new_env;
		   for i = 0 to last_copy do
		     Array.unsafe_set new_env (Array.unsafe_get dest i)
		       (Array.unsafe_get env (Array.unsafe_get source i));
		   code new_env
		 end)
	     : Obj.t array -> Obj.t -> Obj.t);
	fun make_code n code =
	  if n = 0 then
	    (Obj.magic code : Obj.t array -> Obj.t)
	  else
	    make_code (pred n)
	      (Obj.magic (fn env l x => code env (Obj.repr (x::l)))
		 : Obj.t array -> Obj.t -> Obj.t);
	make_code pred_id code
      end
  | UEseq ([], e) =>
      expression alloc e
  | UEseq (cmds1, UEseq (cmds2, e)) =>
      expression alloc (UEseq (cmds1 @ cmds2, e))
  | UEseq (cmds, e) =>
      val ccmds = Array.map (command alloc) (Array.of_list cmds);
      val code = expression alloc e;
      val last = Array.length ccmds - 1;
      if last = 0 then
	begin
	  val ccmd = ccmds.[0];
	  (fn env => begin ccmd env; code env end)
	end
      else
	(fn env =>
	  begin
	    for i = 0 to last do Array.unsafe_get ccmds i env;
	    code env
	  end)
  | UEcase (e, cases, err) =>
      val code = expression alloc e;
      val (i, need_eval) =
	begin
	  case e of
	    UEid id => (find_alloc alloc id, false)
	  | _ => raise Not_found
	  end
	handle
	  Not_found => (add_alloc alloc (new_id "case"), true)
	end;
      val alloc' =
	{ defined = alloc.defined, needed = alloc.needed,
	  size = alloc.size, table = alloc.table };
      List.iter
        (fn (pat,e) =>
	  begin
	    matching alloc' Match_failure pat;
	    expression alloc' e;
	    ()
	  end)
        cases;
      val new_needed = Set.diff alloc'.needed alloc.needed;
      Set.iter (find_alloc alloc) new_needed;
      val needed = alloc.needed and size = alloc.size;
      var max_size = size;
      fun make_code exn (pat, e) =
	begin
	  alloc.size <- size;
	  val mtc = matching alloc exn pat
	  and code = expression alloc e;
	  max_size <- max alloc.size max_size;
	  (fn env =>
	    begin mtc env (Array.unsafe_get env i); code env end)
	end;
      val (cases, last_case) = Misc.split_last cases;
      val codes = List.map (make_code Match_failure) cases
      and last_code = make_code (Match_error err) last_case;
      alloc.size <- max_size;
      if not (Set.equal needed alloc.needed) then failwith "Compile.UEcase";
      fun try_matching env l =
	case l of
	  [] => last_code env
	| coden :: l =>
	    begin coden env handle Match_failure => try_matching env l end
	end;
      if need_eval then
	(fn env =>
	  begin Array.unsafe_set env i (code env); try_matching env codes end)
      else
	(fn env => try_matching env codes)
  | UEifthenelse (e, e1, e2) =>
      val code = expression alloc e
      and code1 = expression alloc e1
      and code2 = expression alloc e2;
      (fn env =>
	if Obj.magic (code env) then code1 env else code2 env)
  | UEset (id, e) =>
      val code = expression alloc e;
      begin
	val i = find_alloc alloc id;
	(fn env => Obj.repr (Array.unsafe_set env i (code env)))
      handle Not_found =>
	begin
	  val oref = Map.find id global.env;
	  (fn env => Obj.repr(oref.contents <- code env))
	handle
	  Not_found => failwith (id.name ^ " not found")
	end
      end
  | UEfor (id, e1, dir, e2, e) =>
      val i = add_alloc alloc id;
      val code1 = expression alloc e1
      and code2 = expression alloc e2
      and code = expression alloc e;
      if dir = Upto then
      	(fn env => Obj.repr(
	  for j = Obj.magic (code1 env) to Obj.magic (code2 env) do
	    begin
	      Array.unsafe_set env i (Obj.repr j);
	      code env
	    end))
      else
      	(fn env => Obj.repr(
	  for j = Obj.magic (code1 env) downto Obj.magic (code2 env) do
	    begin
	      Array.unsafe_set env i (Obj.repr j);
	      code env
	    end))
  | UEwhile (e1, e2) =>
      val code1 = expression alloc e1
      and code2 = expression alloc e2;
      (fn env =>
	Obj.repr(while Obj.magic (code1 env) do code2 env))
  end

fun compile_expression e =
  begin
    val alloc = empty_alloc ();
    val code = expression alloc e;
    (fn () =>
      begin
	val env = Array.create alloc.size (Obj.repr ());
	code env
      end)
  end

fun compile_commands ucmds idents =
  begin
    val alloc = empty_alloc ();
    val codes = List.map (command alloc) ucmds;
    val env = Array.create alloc.size (Obj.repr ());
    List.iter (fn code => code env) codes;
    List.map
      (fn id =>
	begin env.[Map.find id alloc.table]
	handle Not_found =>
	    begin !(Map.find id global.env)
	    handle Not_found => failwith "Compile.compile_commands" end
	end)
    idents
  end

fun prealloc_idents cmds =
  List.flatten
    (List.map
       (fn ue => case ue of UEfun l => List.map fst l | _ => [] end)
       cmds)
