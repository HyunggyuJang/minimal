(* $Id: typechk.mal,v 1.3 1997/10/31 11:11:38 garrigue Exp $ *)

open Common
open Syntax
open Types
open Define
open Unify
open Predef
open Printer

type error =
    Message of string
  | Type_mismatch of string * type_expr * type_expr
  | Multiple_occurence of string * string

exception Type_error of error * location

fun error_message loc s = raise (Type_error (Message s, loc))

fun all_differ loc kind defkind l =
  case l of
    [] => true
  | s :: l =>
      if List.mem s l then
	raise (Type_error
		 (Multiple_occurence
		    (if kind = "" then s else kind ^ " " ^ s,
		     if defkind = "" then "definition"
				     else defkind ^ " definition"),
                  loc))
      else all_differ loc kind defkind l
  end

var type_vars : (string * type_expr) list = []
fun reset_type_vars () =
  begin
    type_vars <- [];
    reset_global_level ()
  end

fun type_expr def sty =
  case sty.st_desc of
    STvar s =>
      begin
	List.assoc s type_vars
      handle Not_found =>
	  if def then
	    error_message sty.st_loc ("unbound type variable '" ^ s);
	  val ty = Tvar (new_global_var ());
	  type_vars <- (s,ty) :: type_vars;
	  ty
      end
  | STarrow (st1, st2) =>
      Tarrow (type_expr def st1, type_expr def st2)
  | STtuple stl =>
      Ttuple (List.map (type_expr def) stl)
  | STconstr (s, stl) =>
      begin
	val info = Hashtbl.find types s;
	if List.length stl <> List.length info.ti_params then
	  error_message sty.st_loc ("wrong arity for type " ^ s);
	subst (List.combine info.ti_params (List.map (type_expr def) stl))
	  info.ti_res
      handle Not_found =>
	  error_message sty.st_loc ("undefined type constructor " ^ s)
      end
  end

var new_constrs = [] and new_labels = []

fun type_kind names vars kind =
  begin
    type_vars <- List.combine names (List.map (fn tv => Tvar tv) vars);
    case kind of
      SKabbrev sty =>
	Kabbrev (type_expr true sty)
    | SKvariant cl =>
	new_constrs <- List.map fst cl @ new_constrs;
	var consts = [] and nonconsts = [];
	List.iter
	  (fn (s,stl) =>
	    if stl = [] then consts <- s :: consts
	    else nonconsts <- (s, List.map (type_expr true) stl) :: nonconsts)
	  cl;
	Kvariant (List.rev consts, List.rev nonconsts)
    | SKrecord fl =>
	new_labels <- List.map (fn (s,_,_) => s) fl @ new_labels;
	Krecord (List.map
		   (fn (s, sty, access) => (s, type_expr true sty, access))
		   fl)
    end
  end

fun add_typedef loc dl =
  begin
    all_differ loc "type" "type" (List.map (fn td => td.sd_name) dl);
    (* add dummy types *)
    val idents =
      List.map
	(fn td =>
	  begin
	    all_differ td.sd_loc "type parameter" "type" td.sd_params;
	    val params = List.map (fn _ => newvar ()) td.sd_params
	    and id = new_id td.sd_name;
	    Hashtbl.add types td.sd_name (make_ti id params Kbasic);
	    id
	  end)
	dl;
    (* remove dummy types and add real types *)
    new_constrs <- []; new_labels <- [];
    val orig_map = global.types;
    begin
      List.iter
	(fn td =>
	  begin
	    val info = Hashtbl.find types td.sd_name;
	    val kind = type_kind td.sd_params info.ti_params td.sd_kind;
	    Hashtbl.remove types td.sd_name;
	    begin
	      add_type td.sd_name { ti_params = info.ti_params,
				    ti_res = info.ti_res,
				    ti_kind = kind }
	    handle exn =>
		Hashtbl.add types td.sd_name info;
		raise exn
	    end
	  end)
	dl;
      all_differ loc "label" "type" new_labels;
      all_differ loc "constructor" "type" new_constrs;
      idents
    handle exn =>
	global.types <- orig_map;
	List.iter (fn td => Hashtbl.remove types td.sd_name) dl;
	raise exn
    end
  end

fun hide_type loc s =
  begin
    val info = Hashtbl.find types s;
    val id =
      case info.ti_res of
	Tconstr (id,_) => id
      |	_ => failwith "Typechk.hyde_type"
      end;
    case info.ti_kind of
      Kbasic => error_message loc ("type " ^ s ^ " is already abstract")
    | Kabbrev _ => ()
    | Kvariant (consts,nonconsts) =>
	val cl = consts @ List.map fst nonconsts;
	if List.exists
	    (fn s => (Hashtbl.find constructors s).ci_res != info.ti_res)
	    cl
	then error_message loc
	  "cannot hide type, some constructors were redefined";
	List.iter (fn s => Hashtbl.remove constructors s) cl
    | Krecord fl =>
	if List.exists
	    (fn (s,_,_) => (Hashtbl.find labels s).li_res != info.ti_res)
	    fl
	then error_message loc
	    "cannot hide type, some labels were redefined";
	List.iter (fn (s,_,_) => Hashtbl.remove labels s) fl
    end;
    Hashtbl.remove types s;
    val info = { ti_params = info.ti_params,
		 ti_res = info.ti_res,
		 ti_kind = Kbasic };
    Hashtbl.add types s info;
    global.types <- Map.add id info global.types
  handle
    Not_found => error_message loc ("type " ^ s ^ " is not defined")
  end

fun newvar () = Tvar (Unify.newvar ())

fun instanciate_scheme ty =
  begin
    var vars = [];
    fun inst ty =
      case repr ty of
	Tvar tv when tv.level = generic_level =>
	  begin
	    List.assq tv vars
	  handle Not_found =>
	      val ty = newvar ();
	      vars <- (tv,ty) :: vars;
	      ty
	  end
      | ty => map_type inst ty
      end;
    inst ty
  end

fun instanciate_type info =
  subst (List.map (fn tv => (tv, newvar())) info.ti_params) info.ti_res

fun instanciate_constr info =
  begin
    val s = List.map (fn tv => (tv, newvar())) info.ci_params;
    (List.map (subst s) info.ci_args, subst s info.ci_res)
  end

fun instanciate_label info =
  begin
    val s = List.map (fn tv => (tv, newvar())) info.li_params;
    (subst s info.li_arg, subst s info.li_res)
  end

fun constant c =
  begin
    val name =
      case c of
	Cint _ => "int"
      | Cchar _ => "char"
      | Cfloat _ => "float"
      end;
    instanciate_type (List.assoc name basic_types)
  end

fun unify_pat pat ty1 ty2 =
  begin
    unify ty1 ty2
  handle Unify =>
    raise (Type_error (Type_mismatch ("Pattern", ty1, ty2), pat.sp_loc))
  end

fun pattern pat =
  case pat.sp_desc of
    SPid s =>
      begin
	val info = Hashtbl.find constructors s;
	if info.ci_args <> [] then
	  error_message pat.sp_loc
	    ("constructor " ^ s ^ " requires an argument");
	val (_, ty_res) = instanciate_constr info;
	(ty_res, [])
      handle Not_found =>
	  val ty = newvar ();
	  (ty, [(s, { vi_type = ty, vi_access = Immutable })])
      end
  | SPconst c => (constant c, [])
  | SPtuple l =>
      val (tyl, bnds) = pattern_list pat.sp_loc l;
      (Ttuple tyl, bnds)
  | SParray l =>
      val (tyl, bnds) = pattern_list pat.sp_loc l;
      val tv = newvar ();
      List.iter2 (fn pat ty => unify_pat pat ty tv) l tyl;
      (Tconstr(id_array, [tv]), bnds)
  | SPconstr (s, spat) =>
      begin
	val info = Hashtbl.find constructors s;
	val (ty_args, ty_res) = instanciate_constr info;
	case ty_args of
	  [] => error_message pat.sp_loc
	      ("constructor " ^ s ^ " takes no argument")
	| [ty_arg] =>
	    val (ty_pat, bnds) = pattern spat;
	    unify_pat spat ty_pat ty_arg;
	    (ty_res, bnds)
	| _ =>
	    case spat.sp_desc of
	      SPtuple l when List.length l = List.length ty_args =>
		val (ty_pats, bnds) = pattern_list pat.sp_loc l;
		Misc.iter3 unify_pat l ty_pats ty_args;
		(ty_res, bnds)
	    | _ =>
		error_message pat.sp_loc
		  ("wrong number of arguments for constructor " ^ s)
	    end
	end
      handle Not_found =>
	  error_message pat.sp_loc ("undefined constructor " ^ s)
      end
  | SPrecord l =>
      val (labl, patl) = List.split l;
      val (ty_args, bnds) = pattern_list pat.sp_loc patl;
      val (ty_fields, ty_recs) =
	List.split (List.map
		 (fn lab =>
		   begin
		     val info = Hashtbl.find labels lab;
		     instanciate_label info
		   handle Not_found =>
		       error_message pat.sp_loc ("undefined label " ^ lab)
		   end)
		 labl)
      and ty_res = newvar ();
      List.iter (unify_pat pat ty_res) ty_recs;
      Misc.iter3 unify_pat patl ty_args ty_fields;
      (ty_res, bnds)
  | SPany => (newvar (), [])
  | SPtype (pat, sty) =>
      val (ty_pat, bnds) = pattern pat
      and ty_res = type_expr false sty;
      unify_pat pat ty_pat ty_res;
      (ty_res, bnds)
  end
	
and pattern_list loc patl =
  begin
    val (tyl,bnds) = List.split (List.map pattern patl);
    val bnds =
      List.fold_right
	(fn bnd bnds =>
	  begin
	    List.iter 
	      (fn (s,_) =>
		if List.mem_assoc s bnds then
		  raise (Type_error
			   (Multiple_occurence ("variable " ^ s, "pattern"),
			    loc)))
	      bnd;
	    bnd @ bnds
	  end)
	bnds [];
    (tyl, bnds)
  end

fun is_constructor e =
  case e.se_desc of
    SEid s =>
      begin
	Hashtbl.find constructors s; true
      handle Not_found => false end
  | _ => false
  end

fun is_nonexpansive e =
  case e.se_desc of
    SEid _ | SEconst _ => true
  | SEtuple l => List.for_all is_nonexpansive l
  | SEarray l => false
  | SErecord l =>
      val (labl, el) = List.split l;
      List.for_all (fn lab => (Hashtbl.find labels lab).li_access <> Mutable)
      	labl
      & List.for_all is_nonexpansive el
  | SEapply (e, [e1]) when is_constructor e => is_nonexpansive e1
  | SEapply _ => false
  | SEfunct _ => true
  | SEseq l => List.for_all cmd_nonexpansive l
  | SEcase (e, cases) =>
      is_nonexpansive e & List.for_all is_nonexpansive (List.map snd cases)
  | SEifthenelse (e1,e2,e3) => List.for_all is_nonexpansive [e1,e2,e3]
  | SEset _ | SEsetfield _ => false
  | SEgetfield (e, _) => is_nonexpansive e
  | SEfor (_, e1, _, e2, e3) => List.for_all is_nonexpansive [e1,e2,e3]
  | SEwhile (e1, e2) => is_nonexpansive e1 & is_nonexpansive e2
  | SEtype (e, _) => is_nonexpansive e
  end

and cmd_nonexpansive cmd =
  case cmd.sc_desc of
    SEexpr e => is_nonexpansive e
  | SEval l => List.for_all is_nonexpansive (List.map snd l)
  | SEfun _ => true
  | SEvar l => List.for_all is_nonexpansive (List.map snd l)
  | STtype _ | SThide _ => failwith "typecheck__cmp_nonexpansive"
  end

fun unify_exp exp ty1 ty2 =
  begin unify ty1 ty2
  handle Unify =>
      raise (Type_error (Type_mismatch ("Expression", ty1, ty2), exp.se_loc))
  end

fun expression bnds e =
  case e.se_desc of
    SEid s when is_constructor e =>
      val info = Hashtbl.find constructors s;
      if info.ci_args <> [] then
	error_message e.se_loc
	  ("wrong number of arguments for constructor " ^ s);
      val (_, ty_res) = instanciate_constr info;
      ty_res
  | SEid s =>
      begin
	val info = Map.find s bnds;
	if info.vi_access = Forbidden then
	  error_message e.se_loc (s ^ " cannot be accessed here");
	instanciate_scheme info.vi_type
      handle
	Not_found => error_message e.se_loc ("unbound identifier " ^ s)
      end
  | SEconst c => constant c
  | SEtuple l =>
      Ttuple (List.map (expression bnds) l)
  | SEarray el =>
      val tv = newvar ();
      List.iter (type_expect bnds tv) el;
      Tconstr(id_array, [tv])
  | SErecord l =>
      val (labl, el) = List.split l;
      val (ty_fields, ty_rec) =
	List.split (List.map
		      (fn lab =>
			begin
			  val info = Hashtbl.find labels lab;
			  instanciate_label info
			handle Not_found =>
			    error_message e.se_loc ("undefined label " ^ lab)
			end)
		      labl)
      and ty_res = newvar ();
      if List.length labl <> (Hashtbl.find labels (List.hd labl)).li_total then
	error_message e.se_loc "some labels are missing";
      List.iter (unify_exp e ty_res) ty_rec;
      List.iter2 (type_expect bnds) ty_fields el;
      ty_res
  | SEapply ({se_desc=SEid s} as e1, el) when is_constructor e1 =>
      val info = Hashtbl.find constructors s;
      val (ty_args, ty_res) = instanciate_constr info;
      case (ty_args, el) of
	([],_) =>
	  error_message e1.se_loc ("constructor " ^ s ^ " takes no argument")
      | ([ty_arg], [e]) =>
	  type_expect bnds ty_arg e;
	  ty_res
      | (_, [{se_desc = SEtuple el}])
	  when List.length el = List.length ty_args =>
	  List.iter2 (type_expect bnds) ty_args el;
	  ty_res
      | _ =>
	  error_message e1.se_loc
	    ("wrong number of arguments for constructor " ^ s)
      end
  | SEapply ({se_desc = SEid ("+"|"-"|"*"|"/"|"~" as op)} as e1, el)
      when el <> [] & (List.length el = 1 or op <> "~")
           & List.length el <= 2 =>
      val ty_args = List.map (expression bnds) el;
      val float = Tconstr(id_float,[])
      and int = Tconstr(id_int,[]);
      val ty_res =
      	if List.exists (fn ty => repr ty = float) ty_args then begin
	  e1.se_desc <- SEid (op ^ "."); float
	end else int;
      List.iter2 (fn e ty => unify_exp e ty ty_res) el ty_args;
      if op = "~"  or List.length el = 2 then
 	ty_res
      else
	Tarrow (ty_res, ty_res)
  | SEapply (e1, el) =>
      val ty1 = expression bnds e1;
      begin filter_arrow ty1
      handle Unify =>
	  error_message e1.se_loc "this expression is not a function"
      end;
      val (ty_args, ty_res) =
	begin
	  List.fold_left
	    (fn (ty_args, ty) _ =>
	      begin
		val (ty_arg, ty_res) = filter_arrow ty;
		(ty_arg :: ty_args, ty_res)
	      end)
	    ([],ty1) el
	handle Unify =>
	    error_message e1.se_loc "too many arguments for this function"
	end;
      List.iter2 (type_expect bnds) (List.rev ty_args) el;
      ty_res
  | SEfunct (patl, e1) =>
      val (_, {sp_loc = {last = last}}) = Misc.split_last patl;
      val (ty_args, new_bnds) =
	pattern_list {first = (List.hd patl).sp_loc.first, last = last}
		     patl;
      var bnds = Misc.add_bindings new_bnds bnds;
      Map.iter
        (fn s info =>
	  if info.vi_access = Mutable then
	    bnds <-
	      Map.add s { vi_type = info.vi_type, vi_access = Forbidden }
	        bnds)
        bnds;
      val ty_res = expression bnds e1;
      List.fold_right (fn ty1 ty2 => Tarrow (ty1, ty2)) ty_args ty_res
  | SEseq cl =>
      val (cl', res) = Misc.split_last cl;
      case res.sc_desc of
	SEexpr e1 =>
	  val bnds = List.fold_left command bnds cl';
	  expression bnds e1
      |	_ =>
	  List.fold_left command bnds cl;
	  Ttuple []
      end
  | SEcase (e1, cases) =>
      val ty_arg = expression bnds e1
      and ty_res = newvar ();
      List.iter
        (fn (pat, e) =>
	  begin
	    val (ty_pat, new_bnds) = pattern pat;
	    unify_pat pat ty_pat ty_arg;
	    val bnds = Misc.add_bindings new_bnds bnds;
	    type_expect bnds ty_res e
	  end)
        cases;
      ty_res
  | SEifthenelse (e1, e2, e3) =>
      type_expect bnds (List.assoc "bool" basic_types).ti_res e1;
      val ty_res = expression bnds e3;
      type_expect bnds ty_res e2;
      ty_res
  | SEset (s, e1) =>
      begin
	val info = Map.find s bnds;
	if info.vi_access = Immutable then
	  error_message e.se_loc (s ^ " is not a mutable variable");
	if info.vi_access = Forbidden then
	  error_message e.se_loc (s ^ " cannot be accessed here");
	type_expect bnds info.vi_type e1;
	Ttuple[]
      handle
	Not_found => error_message e.se_loc ("unbound identifier " ^ s)
      end
  | SEgetfield (e1, s) =>
      begin
	val info = Hashtbl.find labels s;
	val (ty_arg, ty_rec) = instanciate_label info;
	type_expect bnds ty_rec e1;
	ty_arg
      handle
	Not_found => error_message e.se_loc ("undefined label " ^ s)
      end
  | SEsetfield (e1, s, e2) =>
      begin
	val info = Hashtbl.find labels s;
	if info.li_access <> Mutable then
	  error_message e.se_loc("field " ^ s ^ " is not mutable");
	val (ty_arg, ty_res) = instanciate_label info;
	type_expect bnds ty_res e1;
	type_expect bnds ty_arg e2;
	Ttuple[]
      handle
	Not_found => error_message e.se_loc ("undefined label " ^ s)
      end
  | SEfor (s, e1, _, e2, e3) =>
      val type_int = (List.assoc "int" basic_types).ti_res;
      type_expect bnds type_int e1;
      type_expect bnds type_int e2;
      val bnds =
	Map.add s { vi_type = type_int, vi_access = Immutable } bnds;
      statement bnds e3;
      Ttuple[]
  | SEwhile (e1, e2) =>
      type_expect bnds (List.assoc "bool" basic_types).ti_res e1;
      statement bnds e2;
      Ttuple[]
  | SEtype (e1, sty) =>
      val ty = type_expr false sty;
      type_expect bnds ty e1;
      ty
  end

and type_expect bnds ty_expected e =
  case (ty_expected, e.se_desc) of
    (Ttuple tyl, SEtuple el) =>
      List.iter2 (type_expect bnds) tyl el
  | _ =>
      val ty = expression bnds e;
      unify_exp e ty ty_expected
  end

and statement bnds e =
  begin
    val ty = expression bnds e;
    case repr ty of
      Tarrow _ =>
	Printf.eprintf
          "> Char %d-%d : Beware, this function is partially applied.\n"
	  e.se_loc.first e.se_loc.last;
	flush stderr
    | _ => ()
    end;
    ty
  end

and command bnds cmd = 
  begin
    val new_bnds =
      case cmd.sc_desc of
	SEexpr e => statement bnds e; []
      | SEval l =>
	  val (patl, el) = List.split l;
	  begin_def ();
	  val (ty_patl, new_bnds) = pattern_list cmd.sc_loc patl;
	  List.iter2 (type_expect bnds) ty_patl el;
	  end_def ();
	  List.iter2
            (fn ty_pat e =>
	      if (not (is_nonexpansive e)) then make_nongen ty_pat)
            ty_patl el;
	  List.iter generalize ty_patl;
	  new_bnds
      | SEfun l =>
	  val (names, el) = List.split l;
	  all_differ cmd.sc_loc "" "function" names;
	  begin_def ();
	  val new_bnds =
	    List.map
	      (fn s => (s,{vi_type = newvar(), vi_access = Immutable}))
	      names;
	  val bnds = Misc.add_bindings new_bnds bnds;
	  val ty_el = List.map (expression bnds) el;
	  List.iter2
	    (fn (_,info) e => type_expect bnds info.vi_type e)
	    new_bnds el;
	  end_def ();
	  List.iter (fn (_,info) => generalize info.vi_type) new_bnds;
	  new_bnds
      | SEvar l =>
	  val (names, el) = List.split l;
	  all_differ cmd.sc_loc "" "variable" names;
	  val new_bnds =
	    List.map
	      (fn s => (s, {vi_type = newvar(), vi_access = Mutable}))
	      names
	  and ty_el = List.map (expression bnds) el;
	  List.iter2
	    (fn (_,info) e => type_expect bnds info.vi_type e)
	    new_bnds el;
	  new_bnds
      | STtype _ =>
	  error_message cmd.sc_loc "cannot define a type inside an expression"
      | SThide _ =>
	  error_message cmd.sc_loc "cannot hide a type inside an expression"
      end;
    Misc.add_bindings new_bnds bnds
  end

fun type_command values cmd =
  begin
    reset_type_vars ();
    command values cmd
  end

and type_expression values e =
  begin
    reset_type_vars ();
    begin_def ();
    val ty = expression values e;
    end_def ();
    if is_nonexpansive e then generalize ty;
    ty
  end

open Format

fun report_error err =
  case err of
    Message s => print_string s
  | Type_mismatch (kind, ty1,ty2) =>
      Printer.reset_vars ();
      open_hovbox 2;
      force_newline ();
      print_string kind;
      print_string " has type";
      print_space ();
      print_type ty1;
      print_space ();
      print_string "where";
      print_space ();
      print_type ty2;
      print_space ();
      print_string "was expected";
      close_box ()
  | Multiple_occurence (defkind, s) =>
      open_hovbox 2;
      print_string s;
      print_string " occurs multiply in ";
      print_string defkind;
      close_box ()
  end
