(* $Id: toploop.mal,v 1.3 1997/10/31 11:11:37 garrigue Exp $ *)

open Common
open Syntax
open Types
open Define
open Typechk
open Compile
open Printer
open Builtins
open Format
open Lexing
open Printf

fun diff_list l1 l2 =
  if l1 == l2 then [] else List.hd l1 :: diff_list (List.tl l1) l2

exception Line_too_long

var prompt = ""

fun feed_lexer ic echo lines buffer n =
  begin
    fun add_line len =
      lines.contents <- len + List.hd lines.contents :: lines.contents;
    if echo then begin print_string prompt; print_flush () end;
    prompt <- "  ";
    val s = input_line ic;
    val len = String.length s;
    if len > n - 1 then raise Line_too_long;
    String.blit s 0 buffer 0 len;
    String.set buffer len '\n';
    add_line (len + 1);
    len + 1
  handle
    End_of_file => 0
  end

fun get_line n lines =
  case lines of
    [] => (0,0)
  | start :: rest =>
      if start > n then get_line n rest else (List.length lines, start)
  end

fun output_location filename lines oc loc =
  begin
    if filename <> "" then
      fprintf oc "In \"%s\", line " filename
    else fprintf oc "Line ";
    val (line,offset) = get_line loc.first lines;
    fprintf oc "%d, char %d-%d : "
      line (loc.first - offset) (loc.last - offset - 1)
  end

exception Toplevel

var verbose = true

fun do_phrase ph =
  begin
    case ph.sc_desc of
      SEexpr e =>
	val ty = type_expression global.values e;
	val ue = Translate.expression global.idents e;
	val obj = compile_expression ue ();
	flush stdout; flush stderr;
	if verbose then begin
	  open_hovbox 1;
	  print_string "- : ";
	  print_scheme ty;
	  print_string " =";
	  print_space ();
	  print_value ty obj;
	  close_box ();
	  print_newline ()
	end
    | STtype dl =>
	add_typedef ph.sc_loc dl;
	if verbose then
	  List.iter
	    (fn td =>
	      print_endline ("type " ^ td.sd_name ^ " defined."))
	    dl
    | SThide s =>
	hide_type ph.sc_loc s;
	print_endline ("type " ^ s ^ " is now abstract.")
    | _ =>
	val new_values = type_command global.values ph;
	val (ucmds, new_idents) = Translate.command global.idents ph;
	val idents = diff_list new_idents global.idents;
	(* Some values must be preallocated *)
	List.iter 
	  (fn id =>
	    add_value id (Obj.repr ()) (Map.find id.name new_values))
	  (prealloc_idents ucmds);
	val objs = compile_commands ucmds (List.map snd idents);
	flush stdout; flush stderr;
	(* Only add values that where not preallocated *)
	List.iter2
	  (fn (s,id) obj =>
	    begin Map.find id global.env; ()
	    handle Not_found => add_value id obj (Map.find s new_values)
	    end)
	  idents objs;
	if verbose then
	  List.iter2
	    (fn (s,_) obj =>
	      begin
		val info = Map.find s new_values;
		open_hovbox 1;
		print_string 
		  (if info.vi_access = Mutable then "var " else "val ");
		print_string (s ^ " :");
		print_space ();
		print_scheme info.vi_type;
		print_string " =";
		print_space ();
		print_value info.vi_type obj;
		close_box ();
		print_newline ()
	      end)
	    idents objs
    end
  handle exn =>
      if handle_exn exn then raise Toplevel else raise exn
  end

fun report_error lexbuf filename lines exn =
  begin
    case exn of
      Parsing.Parse_error =>
	eprintf "> %aSyntax error." (output_location filename lines)
          { first = Lexing.lexeme_start lexbuf,
	    last = Lexing.lexeme_end lexbuf };
	prerr_endline ""
    | Lexer.Lexical_error (_, start, stop) =>
	eprintf "> %aLexical error." (output_location filename lines)
          {first = start, last = stop};
	prerr_endline ""
    | Type_error (err, loc) =>
	set_formatter_out_channel stderr;
	eprintf "> %a" (output_location filename lines) loc;
	val (o,f) = get_formatter_output_functions ();
	Typechk.report_error err;
	print_string "."; print_newline ();
	set_formatter_output_functions o f
    | Line_too_long =>
	eprintf "> Too long line in \"%s\", line %d."
          filename (List.length lines);
	prerr_endline ""
    | Sys.Break =>
	prerr_endline "Interrupted!"
    | _ => raise exn
    end;
    raise Toplevel
  end

fun load s =
  begin
    val name = Misc.string_of_array s ^ ".mal";
    val ic =
      begin open_in name
      handle Sys_error _ =>
	  prerr_endline ("> Could not open \"" ^ name ^ "\".");
	  raise Toplevel
      end;
    val lines = ref [0];
    val lexbuf = Lexing.from_function (feed_lexer ic false lines);
    begin
      while true do
	List.iter do_phrase (Parser.phrase Lexer.main lexbuf)
    handle exn =>
	close_in ic;
	case exn of
	  End_of_file => ()
	| _ => report_error lexbuf name !lines exn
	end
    end
  end;

add_builtin ("use", Obj.repr load, arr string unit);

fun minimal () =
  begin
    Sys.catch_break true;
    open_hbox ();
    print_string ">\tMiniMAL version 0.05 on O'Caml/MAL";
    print_newline (); print_newline ();
    while true do begin
      val lines = ref [0];
      val lexbuf = Lexing.from_function (feed_lexer stdin true lines);
      begin
	while true do begin
	  flush stdout; flush stderr;
	  prompt <- "# ";
	  lines.contents <- [List.hd lines.contents];
	  List.iter do_phrase (Parser.phrase Lexer.main lexbuf)
	end
      handle exn =>
	  begin report_error lexbuf "" !lines exn
	  handle Toplevel => () end
      end
    end
  handle
    End_of_file => close_box ()
  end;

process_builtins ();

Printexc.print minimal ();
