(* classical : imperative reverse *)

fun imp_rev l =
  begin
    var l = l;
    var r = [];
    while l <> [] do begin
      val a :: l' = l;
      l <- l';
      r <- a :: r;
    end;
    r
  end;

(* sorting using arrays *)

fun merge_sort compare array =
  if length array < 2 then array else
  begin
    val middle = length array / 2;
    val rest = length array - middle;
    val left = merge_sort compare (sub array 0 middle)
    and right = merge_sort compare (sub array middle rest);
    var i = 0 and j = 0;
    for k = 0 to length array - 1 do
      if i = middle or j < rest & compare right.[j] left.[i] then
 	begin
 	  array.[k] <- right.[j]; j <- j+1
      	end
      else
 	begin
	  array.[k] <- left.[i]; i <- i+1
      	end;
    array
  end;

(* order induced on strings is not lexicographical *)

fun min a b = if a < b then a else b ;

fun lexico cmp s1 s2 =
  begin
    val sz = min (length s1) (length s2);
    fun lex_rec n =
      if n = sz then
 	if length s1 = length s2 then 0 else
 	if length s1 < length s2 then -1 else 1
      else
	if cmp s1.[n] s2.[n] = 0 then lex_rec (n+1) else
	if cmp s1.[n] s2.[n] < 0 then -2 else 2
    ;
    lex_rec 0
  end
;

fun compare_of_lt lt a b =
  if lt a b then -1 else if lt b a then 1 else 0 ;

fun string_lt s1 s2 = lexico (compare_of_lt (<)) s1 s2 < 0 ;

(* Graph algorithms *)

require "prelude";

fun index x l =
  case l of
    [] => raise "Not_found"
  | a::l => if x = a then 0 else 1 + index x l
  end

type ('a,'b) graph = {vertices: 'a list, edges: (int*'b) list array}

fun add_edge g a (b,w) =
  begin
    val e = g.edges;
    val i = index a g.vertices and j = index b g.vertices;
    e.[i] <- (j,w) :: e.[i];
    e.[j] <- (i,w) :: e.[j]
  end

fun build_graph ll =
  begin
    val len = length_list ll and names = map_list fst ll;
    val g = {vertices = names, edges = array len []};
    do_list (fn (a, neighbours) => do_list (add_edge g a) neighbours) ll;
    g
  end

fun connected0 G C (n,w) =
  if C.[n] then () else begin
    C.[n] <- true;
    do_list (connected0 G C) G.edges.[n]
  end

fun connected G n =
  begin
    val C = array (length G.edges) false;
    connected0 G C (index n G.vertices,0);
    C
  end

val distances =
  [ ("Nagoya", [("Sakae", 2), ("Hisaya", 3)]),
    ("Sakae", [("Hisaya", 1), ("Imaike", 3)]),
    ("Hisaya", [("Imaike", 3), ("Motoyama", 11)]),
    ("Imaike", [("Motoyama", 3)]),
    ("Motoyama", [("Daigaku", 1)]),
    ("Daigaku", []) ]

val graph = build_graph distances

(* Shortest path *)

type status = Reached of int * int | Fringe of int * int | Unseen

fun visit_neighbour status source srcdist (next, dist) =
  case status.[next] of
  | Reached (_, _) => ()
  | Fringe (d, src) =>
      val d' = srcdist + dist;
      if d' < d then status.[next] <- Fringe (d', source)
  | Unseen =>
      status.[next] <- Fringe (srcdist + dist, source)
  end

fun closest_fringe status =
  begin
    var closest = 0;
    for i = 0 to length status - 1 do
      case (status.[closest], status.[i]) of
      | (Fringe (d, _), Fringe (di, _)) =>
          if di < d then closest <- i
      | (_, Fringe (_, _)) => closest <- i
      | _ => ()
      end;
    closest
  end

fun shortest_rec graph status =
  begin
    val next = closest_fringe status;
    case status.[next] of
      Fringe (d, src) =>
	status.[next] <- Reached (d, src);
	do_list (visit_neighbour status next d) graph.edges.[next];
	shortest_rec graph status
    | _ => ()
    end
  end

fun shortest_paths graph start =
  begin
    val status = array (length graph.edges) Unseen;
    status.[index start graph.vertices] <- Fringe (0, -1);
    shortest_rec graph status;
    status
  end

fun read_path graph status dest =
  begin
   fun path v p =
     if v = -1 then p else
     case status.[v] of
     | Reached (_, src) => path src (nth v graph.vertices :: p)
     | _ => raise "unreached"
     end;
    path (index dest graph.vertices) []
  end

fun shortest_path graph start dest =
  begin
    val status = shortest_paths graph start;
    val v = index dest graph.vertices;
    case status.[v] of
    | Reached (d, _) => Some (d, read_path graph status dest)
    | _ => None
    end
  end;

shortest_path graph "Nagoya" "Daigaku";
