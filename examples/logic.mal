fun lxorp x y =
  if y = 0 then x else
  if x = 0 then y else
  begin
    val hi = 2 * lxorp (x/2) (y/2);
    val lo = x mod 2;
    if y mod 2 = 0 then lo + hi else 1-lo + hi
  end;

fun lxor x y =
  begin
    val x' = if x >= 0 then x else x - minint;
    val y' = if y >= 0 then y else y - minint;
    val z = lxor x' y';
    if x+y = x'+y' then z else z - minint
  end;

fun land x y =
  if x = 0 or y = 0 then 0 else
  begin
    val hi = 2 * land (x/2) (y/2);
    if (x mod 2 = 1) or (y mod 2 = 1) then hi+1 else hi
  end;

fun shl x y =
  if y <= 0 then x else
  shl (x*2) (y-1);

fun shrp x y =
  if y <= 0 then x else
  shrp (x/2) (y-1);
  
fun shr x y =
  if x >= 0 then shrp x y else
  shrp (x-minint) y - (minint/2);

fun sarm x y =
  if y <= 0 then x else
  sarm ((x+1)/2) (y-1) - 1

fun sar x y =
  if x >= 0 then shrp x y else sarm x y;

fun hex_of_int n =
  begin
    val k = n mod 16;
    val s = if n > 15 then hex_of_int (n / 16) else "";
    val d = if k < 10 then char (code '0' + k) else char (code 'a' + k - 10);
    s ^ [|d|]
  end;

fun int_of_hex s =
  if s = "" then 0 else
  begin
    val len = length s - 1;
    val c = s.[len];
    val d =
      if c >= '0' & c <= '9' then code c - code '0' else
      if c >= 'a' & c <= 'f' then code c - code 'a' + 10 else
      if c >= 'A' & c <= 'F' then code c - code 'A' + 10 else 0;
    d + 16 * int_of_hex (sub s 0 len)
  end;
