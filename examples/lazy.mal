(* Encoding of lazyness *)

type 'a frozen =
    Cooked of 'a
  | Freeze of (unit -> 'a)

fun cook lazy =
  case lazy of
    Cooked x => x
  | Freeze f => f ()
  end

(* Defining an ADT for lazy lists *)

  type 'a llist = {car: 'a , mutable cdr: 'a llist frozen}

  (* Constructors *)

  fun fcons a f = {car = a, cdr = Freeze f}
  fun ccons a ll = {car = a, cdr = Cooked ll}

  (* Destructors *)

  fun car {car=x} = x

  fun cdr ll =
    case ll.cdr of
      Cooked x => x
    | Freeze f => val x = f (); ll.cdr <- Cooked x; x
    end

  fun ready ll =		(* checking state of evaluation *)
    ll.car ::
      (case ll.cdr of
      	Freeze _ => []
      | Cooked ll => ready ll
      end)

(* now we pack the ADT *)
hide llist


(* Example: computing primes with lazy lists *)

fun nats n = fcons n (fn () => nats (n+1))

val all_nats = nats 0

fun nth_lazy n ll = if n = 0 then car ll else nth_lazy (n-1) (cdr ll)

fun map_lazy f ll =
  fcons (f (car ll)) (fn () => map_lazy f (cdr ll))

fun filter_lazy pred ll =
  if pred (car ll)
  then fcons (car ll) (fn () => filter_lazy pred (cdr ll))
  else filter_lazy pred (cdr ll)

fun prime ll = filter_lazy (fn m => m mod (car ll) <> 0) (cdr ll)
fun primes ll = fcons (car ll) (fn () => primes (prime ll))

val all_primes = primes (nats 2)
