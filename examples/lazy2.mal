(* Another Erathostenes sieve *)

type 'a lazylist = Nil | Cons of 'a lazycell
and 'a lazycell = {hd: 'a, mutable tl: 'a lazyval}
and 'a lazyval = Known of 'a lazylist | Unknown of (unit -> 'a lazylist)

fun cons head f = Cons {hd = head, tl = Unknown f}
fun natfrom n = cons n (fn () => natfrom (n+1))

fun hd (Cons cell) = cell.hd
fun tl (Cons cell) =
  case cell.tl of
    Known l =>
      l
  | Unknown f =>
      val l = f ();
      cell.tl <- Known l;
      l
  end

fun map f l =
  case l of
    Nil => Nil
  | _ => cons (f (hd l)) (fn () => map f (tl l)) 
  end

fun filter pred l =
  case l of
    Nil => Nil
  | _ =>
      if pred (hd l)
      then cons (hd l) (fn () => filter pred (tl l))
      else filter pred (tl l)
  end

fun filter_multiples l = filter (fn m => m mod (hd l) <> 0) (tl l)
fun primes l = cons (hd l) (fn () => primes (filter_multiples l))

val all_primes = primes (natfrom 2)

(* utility functions *)

fun nth n l = if n <= 0 then hd l else nth (n-1) (tl l)
fun ready l =
  case l of
    Nil => []
  | Cons {hd=head, tl=Unknown f} => [head]
  | Cons {hd=head, tl=Known l} => head :: ready l
  end
fun avail l =
  begin
    fun avail l acc =
      case l of
    	Nil => acc
      | Cons {tl=Unknown f} => acc + 1
      | Cons {tl=Known l} => avail l (acc + 1)
      end;
    avail l 0
  end

fun lazy l =
  case l of
    [] => Nil
  | a::l => Cons{hd = a, tl = Known (lazy l)}
  end

(* Maximum segment sum *)

fun fold f acc l =
  case l of 
    Nil => acc
  | _ => fold f (f acc (hd l)) (tl l)
  end

fun scan f acc l =
  case l of
    Nil => Nil
  | _ =>
      val acc = f acc (hd l);
      cons acc (fn () => scan f acc (tl l))
  end

fun append l1 l2 =
  case l1 of
    Nil => l2
  | _ => cons (hd l1) (fn () => append (tl l1) l2)
  end

fun concat l =
  case l of
    Nil => Nil
  | Cons {hd=Nil} => concat (tl l)
  | Cons cell =>
      val l1 = hd l;
      cons (hd l1) (fn () => concat (Cons {hd = tl l1, tl = cell.tl}))
  end

fun inits l =
  cons
    Nil
    (fn () =>
      scan
 	(fn acc x => append acc (Cons{hd=x,tl=Known Nil}))
 	Nil
 	l)

fun tails l =
  Cons {hd = l,
	tl =
      	  case l of
      	    Nil => Known Nil
	  | _ => Unknown (fn () => tails (tl l))
	  end}

fun max x y = if x > y then x else y
val maxl = fold max minint
val sum = fold (+) 0

(* direct version *)
fun mss1 lst = maxl (map sum (concat (map tails (inits lst))))
fun amss1 lst = map mss1 (inits lst)

(* do not repeat same thing *)
fun tmss lst = maxl (map sum (tails lst))
fun mss2 lst = maxl (map tmss (inits lst))
fun amss2 lst = scan max minint (map tmss (inits lst))

(* after Horner transformation *)
fun amss3 lst = scan max minint (scan (fn x y => max (x+y) 0) 0 lst)

(* no intermediate structure *)
fun scanfold f acc1 acc2 l =
  case l of
    Nil => Nil
  | _ =>
      val (acc1',acc2') = f acc1 acc2 (hd l);
      cons acc1' (fn () => scanfold f acc1' acc2' (tl l))
  end
fun maxsum u v x =
  begin
    val w = max (v+x) 0;
    (max u w, w)
  end
fun amss4 lst = scanfold maxsum 0 0 lst

fun make_rands n = cons (n/3 - random_int n) (fn () => make_rands n)
val rands = make_rands 12
