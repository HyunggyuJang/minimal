(* $Id: automaton.mal,v 1.4 2004/10/20 13:26:27 garrigue Exp $ *)

(* Auxiliary functions *)

(* init : int -> (int -> 'a) -> 'a array *)
(* (init n f) builds the array [|f 0, ..., f (n-1)|] *)
fun init len f =
  begin
    val arr = array len (f 0);
    for i = 1 to len-1 do arr.[i] <- f i;
    arr
  end

(* matrix : int -> int -> 'a -> 'a array array *)
(* (matrix m n a) creates a matrix of size m*n filled with a's *)
fun matrix m n a = init m (fn _ => array n a)

(* fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a *)
(* (fold_left (+) x0 [x1,...,xn]) computes ((x0 + x1) ... + xn) *)
fun fold_left f acc l =
  case l of [] => acc
  | a::l => fold_left f (f acc a) l
  end

fun max x y = if x > y then x else y

fun mem a l =
  case l of [] => false
  | b :: l => a=b or mem a l
  end

fun add a l = if mem a l then l else a::l

fun union l1 l2 = fold_left (fn l x => add x l) l2 l1

fun rev l = fold_left (fn l x => x::l) [] l

(* Automaton minimization *)

(* Compute distinct states *)
fun propagate dep diff q0 q1 =
  if not diff.[q0].[q1] then begin
    diff.[q0].[q1] <- true;
    do_list (fn (q2,q3) => propagate dep diff q2 q3) dep.[q0].[q1]
  end

fun diffs delta final =
  begin
    val n = length final and z = length delta;
    val diff = init n (fn i => array i false);
    val dep = init n (fn i => array i []);
    for i = 1 to n-1 do for j = 0 to i-1 do
      for a = 0 to z-1 do begin
	val q2 = delta.[a].[i] and q3 = delta.[a].[j];
	if q2 > q3 then dep.[q2].[q3] <- (i,j)::dep.[q2].[q3] else
	if q3 > q2 then dep.[q3].[q2] <- (i,j)::dep.[q3].[q2]
      end;
    for i = 1 to n-1 do for j = 0 to i-1 do
      if (final.[i] : bool) <> final.[j] then propagate dep diff i j;
    (diff, dep)
  end

(* Compute reachable states, starting from state 1 *)
fun reachable delta =
  begin
    val z = length delta and n = length delta.[0];
    val reached = array n false;
    fun loop k =
      if not reached.[k] then begin
        reached.[k] <- true;
        for a = 0 to z-1 do loop delta.[a].[k]
      end;
    loop 1;
    reached
  end

(* Minimize the automaton, eliminating redundant and unreachable states.
   Assume that q0 is state 1 and error is state 0 *)
fun minimize delta final =
  begin
    val (diff, _) = diffs delta final;
    val reached = reachable delta;
    val n = length final;
    val map = array n 0;
    var next = 1;
    for i = 1 to n-1 do begin
      var k = 0;
      if reached.[i] then
        while k < i & (diff.[i].[k] or not reached.[k]) do k <- k+1;
      if k != i then map.[i] <- map.[k] else begin
	map.[i] <- next;
	next <- next + 1;
      end
    end;
    val size = next;
    val delta' =
      map_array
	(fn arr => begin
	  val arr' = array size (-1);
	  for i = 0 to n-1 do begin
	    val j = map.[i];
	    if arr'.[j] = -1 then
	      arr'.[j] <- map.[arr.[i]]
	  end;
	  arr'
	end)
	delta;
    val final' = array size false;
    for i = 1 to n-1 do
      if map.[i] > 0 then final'.[map.[i]] <- final.[i];
    (delta', final')
  end

(* Apply the automaton to w, starting in state q *)
fun run delta q w =
  case w of [] => q
  | a::w => run delta delta.[a].[q] w
  end

val M = [|[|0, 2, 2, 4, 4|], [|0, 3, 0, 0, 0|]|]
val F = [|false, false, true, false, true|]


(* Conversion from epsilon-nondeterministic to deterministic *)

(* Closure *)
fun closure eps k =
  if k = 0 then eps else begin
    val eps' =
      map_array
        (fn ql => fold_left (fn ql q => union eps.[q] ql) ql ql)
        eps;
    closure eps' (k lsr 1)
  end

(* Epsilon-completion, converting from a list of rules to a matrix.
   Rules are of the form (a,q,ql), with (a) a symbol, (q) a state,
   and (ql) a list of states. The symbol 0 represents epsilon.
   The output matrix delta corresponds to rules (a,q,delta.[a-1].[q]) *)
fun complete rules =
  begin
    val (z,n) =
      fold_left
	(fn (z,n) (a,q,ql) => (max a z, fold_left max n (q::ql)))
	(0,0) rules;
    val n = n+1;
    val delta = matrix z n [];
    val epsilon = array n [];
    do_list
      (fn (a,q,ql) =>
        begin
          val arr = if a = 0 then epsilon else delta.[a-1];
          arr.[q] <- union arr.[q] ql
        end)
      rules;
    val epsilon = closure epsilon (n-1);
    val delta' = matrix z n [];
    for a = 0 to z-1 do for i = 0 to n-1 do begin
      val ql0 = add i epsilon.[i];
      val ql1 = fold_left (fn ql q => union delta.[a].[q] ql) [] ql0;
      delta'.[a].[i] <-
        fold_left (fn ql q => union epsilon.[q] ql) ql1 ql1
    end;
    delta'
  end

(* Build a deterministic automaton from a list of rules defining
   an epsilon-undeterministic one *)
fun determinize rules final =
  begin
    val delta = complete rules;
    val z = length delta and n = length delta.[0];
    val pn = 1 lsl n;
    val fbits =
      fold_left (fn bits n => bits lor (1 lsl n)) 0 final;
    val final' =
      init pn (fn n => n land fbits <> 0);
    val delta' =
      init z (fn _ => array pn 0);
    for a = 0 to z-1 do for i = 0 to n-1 do begin
      val q = 1 lsl i;
      val ql = fold_left (fn n j => n lor (1 lsl j)) 0 delta.[a].[i];
      if ql <> 0 then
        for k = 1 to pn-1 do
          if k land q <> 0 then
            delta'.[a].[k] <- delta'.[a].[k] lor ql
    end;
    (delta', final')
  end

val rules = [(0,0,[1]), (1,1,[2]), (1,2,[2]), (2,0,[1])]
val final = [2]


(* Regular expressions *)

type regexp == elt list
and elt = Char of char | Or of regexp list | Star of elt

fun parse_simple r0 s pos =
  if pos >= length s then (pos,r0) else
  case s.[pos] of
  | '(' =>
      val (pos,rl) = parse_or [] s (pos+1);
      val r =
        case rl of
        | [r] => r @ r0
        | _ => Or rl :: r0
        end;
      if s.[pos] = ')' then parse_simple r s (pos+1)
                       else raise "parse_reg"
  | '|' => (pos,r0)
  | ')' => (pos,r0)
  | '*' =>
      case r0 of [] => raise "nothing to repeat"
      | a::r => (pos, Star a :: r)
      end
  | '\\' => parse_simple (Char s.[pos+1] :: r0) s (pos+2)
  | c => parse_simple (Char c :: r0) s (pos+1)
  end
and parse_or rl s pos =
  if pos >= length s then (pos,rl) else begin
    val (pos,r) = parse_simple [] s pos;
    val rl = rev r :: rl;
    if pos >= length s then (pos,rl) else
    case s.[pos] of
    | '|' => parse_or rl s (pos+1)
    | _ => (pos,rl)
    end
  end

fun parse_reg s =
  case parse_or [] s 0 of
  | (_,[r]) => r
  | (_,rl) => [Or rl]
  end

fun chars_elt e =
  case e of
  | Char c => [c]
  | Or rl => fold_left (fn l r => union l (chars r)) [] rl
  | Star r => chars_elt r
  end
and chars r =
  fold_left (fn l e => union (chars_elt e) l) [] r

type 'a ref = {mutable v: 'a}
fun next r =
  begin val v = r.v; r.v <- v + 1; v end

fun build_elt map c q0 qf e =
  case e of
  | Char c => [(map.[code c], q0, [qf])]
  | Or rl =>
      fold_left (fn l r => build_reg map c q0 qf r @ l) [] rl
  | Star e =>
      val q0' = next c and qf' = next c;
      (0, q0, [q0']) :: (0, q0, [qf]) :: (0, qf', [qf]) :: (0, qf', [q0'])
        :: build_elt map c q0' qf' e
  end
and build_reg map c q0 qf r =
  case r of
  | [e] => build_elt map c q0 qf e
  | e::r =>
      val q0' = next c;
      build_elt map c q0 q0' e @ build_reg map c q0' qf r
  | [] => [(0,q0,[qf])]
  end

fun build s =
  begin
    val r = parse_reg s;
    val l = chars r;
    val map = array 256 0;
    val z = {v=1};
    do_list (fn c => map.[code c] <- next z) l;
    val c = {v = 0};
    val q0 = next c and qf = next c;
    (build_reg map c q0 qf r, [qf], l)
  end

val (rules', final',chars') = build "(+|-|)(0|1)(0|1)*"
val (M', F') = determinize rules' final'
val (M'', F'') = minimize M' F'