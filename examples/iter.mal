(* Quicksort with partition via iteration *)

fun sort1 l =
  case l of [] => []
  | a::l =>
      var l = l and l1 = [] and l2 = [];
      while l <> [] do begin
	val b::tail = l;
	l <- tail;
	if b < a then l1 <- b::l1 else l2 <- b::l2
      end;
      sort1 l1 @ a :: sort1 l2
  end

(* Quicksort using fold_left : longer *)

fun sort2 l =
  case l of [] => []
  | a::l =>
      val (l1,l2) =
        fold_left
          (fn (l1,l2) b => if b < a then (b::l1,l2) else (l1,b::l2))
          ([],[]) l;
      sort2 l1 @ a :: sort2 l2
  end

(* Quicksort fully recursive : longer *)

fun sort3 l =
  case l of [] => []
  | a::l =>
      fun split l l1 l2 =
        case l of [] => (l1,l2)
        | b::l =>
            if b < a then split l (b::l1) l2 else split l l1 (b::l2)
        end;
      val (l1,l2) = split l [] [];
      sort3 l1 @ a :: sort3 l2
  end

(* Quicksort on arrays : very long *)

fun sort4 arr =
  begin
    fun swap i j =
      begin
        val x = arr.[i];
        arr.[i] <- arr.[j];
        arr.[j] <- x
      end;
    fun sort i j =
      begin
        val l = j - i;
        if l < 2 then () else
        if l = 2 then
          if arr.[i] > arr.[i+1] then swap i (i+1) else ()
        else begin
          val pivot = arr.[i + random_int l];
          var i' = i and j' = j-1;
          while i' < j' do begin
            while arr.[i'] < pivot do i' <- i'+1;
            while pivot < arr.[j'] do j' <- j'-1;
            if i' < j' then begin
              swap i' j'; i' <- i'+1; j' <- j'-1
            end
          end;
          sort i i';
          sort i' j
        end
      end;
    sort 0 (length arr);
    arr
  end
