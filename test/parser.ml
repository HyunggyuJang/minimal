module Parser = Minimal.Parser
module Lexer = Minimal.Lexer
open Minimal.Syntax

(* Generated by menhir *)
let print_token : Parser.token -> string =
 fun _tok ->
  match _tok with
  | AMPERSAND -> "AMPERSAND"
  | AND -> "AND"
  | BAR -> "BAR"
  | BARRBRACKET -> "BARRBRACKET"
  | BEGIN -> "BEGIN"
  | CASE -> "CASE"
  | CHAR _ -> "CHAR"
  | COLON -> "COLON"
  | COLONCOLON -> "COLONCOLON"
  | COMMA -> "COMMA"
  | DO -> "DO"
  | DOT -> "DOT"
  | DOWNTO -> "DOWNTO"
  | ELSE -> "ELSE"
  | END -> "END"
  | EOF -> "EOF"
  | EQUAL -> "EQUAL"
  | EQUALEQUAL -> "EQUALEQUAL"
  | EQUALGREATER -> "EQUALGREATER"
  | FLOAT f -> "FLOAT " ^ string_of_float f
  | FN -> "FN"
  | FOR -> "FOR"
  | FUN -> "FUN"
  | HIDE -> "HIDE"
  | IDENT s -> "IDENT " ^ s
  | IF -> "IF"
  | IN -> "IN"
  | INFIX0 _ -> "INFIX0"
  | INFIX1 _ -> "INFIX1"
  | INFIX2 _ -> "INFIX2"
  | INFIX3 _ -> "INFIX3"
  | INFIX4 _ -> "INFIX4"
  | INT i -> "INT " ^ string_of_int i
  | LBRACE -> "LBRACE"
  | LBRACKET -> "LBRACKET"
  | LBRACKETBAR -> "LBRACKETBAR"
  | LESSMINUS -> "LESSMINUS"
  | LPAREN -> "LPAREN"
  | MINUSGREATER -> "MINUSGREATER"
  | MUTABLE -> "MUTABLE"
  | OF -> "OF"
  | OR -> "OR"
  | PREFIX _ -> "PREFIX"
  | QUOTED _ -> "QUOTED"
  | RBRACE -> "RBRACE"
  | RBRACKET -> "RBRACKET"
  | RPAREN -> "RPAREN"
  | SEMI -> "SEMI"
  | STAR -> "STAR"
  | STRING s -> "STRING " ^ s
  | SUBTRACTIVE _ -> "SUBTRACTIVE"
  | THEN -> "THEN"
  | TO -> "TO"
  | TYPE -> "TYPE"
  | UNDERSCORE -> "UNDERSCORE"
  | VAL -> "VAL"
  | VAR -> "VAR"
  | WHILE -> "WHILE"
;;

let expression_testable = Alcotest.testable pp_expression_desc ( = )

let test_tokens () =
  let open Lexer in
  let success_table =
    [ "var", "VAR", "var"
    ; "string", "STRING test", {|"test"|}
    ; "ident", "IDENT ident", "ident"
    ; "number", "INT 237", "237"
    ; "negative", "SUBTRACTIVE", "-237"
    ; "float", "FLOAT 23.8", "23.8"
    ]
  in
  let failure_table =
    [ ( "unterminated string"
      , Lexical_error (Unterminated_string, 0, 13)
      , {|"unterminated|} )
    ; ( "unterminated comment"
      , Lexical_error (Unterminated_comment, 0, 15)
      , "(* unterminated" )
    ]
  in
  List.iter
    (fun (name, expected, input) ->
      Lexing.from_string input
      |> main
      |> print_token
      |> Alcotest.(check string) name expected)
    success_table;
  List.iter
    (fun (name, exn, input) ->
      Alcotest.check_raises name exn (fun () ->
          let _ = Lexing.from_string input |> main in
          ()))
    failure_table
;;

let test_simple_expr () =
  let open Parser in
  let success_table = [ "ident", SEid "ident", "ident" ] in
  List.iter
    (fun (name, expected, input) ->
      Lexing.from_string input |> phrase Lexer.main |> fun e ->
      (match (List.hd e).sc_desc with
      | SEexpr exp -> exp.se_desc
      | _ -> assert false)
      |> Alcotest.check expression_testable name expected)
    success_table;
  Lexing.from_string {|"string"|} |> phrase Lexer.main |> fun e ->
  (match (List.hd e).sc_desc with
  | SEexpr exp -> show_expression_desc exp.se_desc
  | _ -> assert false)
  |> Alcotest.(check string)
       "string"
       {|(Syntax.SEarray
   [{ Syntax.se_desc = (Syntax.SEconst (Common.Cchar 115)); se_loc = <opaque>
      };
     { Syntax.se_desc = (Syntax.SEconst (Common.Cchar 116));
       se_loc = <opaque> };
     { Syntax.se_desc = (Syntax.SEconst (Common.Cchar 114));
       se_loc = <opaque> };
     { Syntax.se_desc = (Syntax.SEconst (Common.Cchar 105));
       se_loc = <opaque> };
     { Syntax.se_desc = (Syntax.SEconst (Common.Cchar 110));
       se_loc = <opaque> };
     { Syntax.se_desc = (Syntax.SEconst (Common.Cchar 103));
       se_loc = <opaque> }
     ])|}
;;

let () =
  Alcotest.run
    "Parser"
    [ ( "parse"
      , [ Alcotest.test_case "tokens" `Quick test_tokens
        ; Alcotest.test_case "simple expressions" `Quick test_simple_expr
        ] )
    ]
;;
