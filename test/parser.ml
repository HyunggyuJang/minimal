module Parser = Minimal.Parser
module Lexer = Minimal.Lexer

(* Generated by menhir *)
let print_token : Parser.token -> string =
 fun _tok ->
  match _tok with
  | AMPERSAND -> "AMPERSAND"
  | AND -> "AND"
  | BAR -> "BAR"
  | BARRBRACKET -> "BARRBRACKET"
  | BEGIN -> "BEGIN"
  | CASE -> "CASE"
  | CHAR _ -> "CHAR"
  | COLON -> "COLON"
  | COLONCOLON -> "COLONCOLON"
  | COMMA -> "COMMA"
  | DO -> "DO"
  | DOT -> "DOT"
  | DOWNTO -> "DOWNTO"
  | ELSE -> "ELSE"
  | END -> "END"
  | EOF -> "EOF"
  | EQUAL -> "EQUAL"
  | EQUALEQUAL -> "EQUALEQUAL"
  | EQUALGREATER -> "EQUALGREATER"
  | FLOAT _ -> "FLOAT"
  | FN -> "FN"
  | FOR -> "FOR"
  | FUN -> "FUN"
  | HIDE -> "HIDE"
  | IDENT _ -> "IDENT"
  | IF -> "IF"
  | IN -> "IN"
  | INFIX0 _ -> "INFIX0"
  | INFIX1 _ -> "INFIX1"
  | INFIX2 _ -> "INFIX2"
  | INFIX3 _ -> "INFIX3"
  | INFIX4 _ -> "INFIX4"
  | INT _ -> "INT"
  | LBRACE -> "LBRACE"
  | LBRACKET -> "LBRACKET"
  | LBRACKETBAR -> "LBRACKETBAR"
  | LESSMINUS -> "LESSMINUS"
  | LPAREN -> "LPAREN"
  | MINUSGREATER -> "MINUSGREATER"
  | MUTABLE -> "MUTABLE"
  | OF -> "OF"
  | OR -> "OR"
  | PREFIX _ -> "PREFIX"
  | QUOTED _ -> "QUOTED"
  | RBRACE -> "RBRACE"
  | RBRACKET -> "RBRACKET"
  | RPAREN -> "RPAREN"
  | SEMI -> "SEMI"
  | STAR -> "STAR"
  | STRING _ -> "STRING"
  | SUBTRACTIVE _ -> "SUBTRACTIVE"
  | THEN -> "THEN"
  | TO -> "TO"
  | TYPE -> "TYPE"
  | UNDERSCORE -> "UNDERSCORE"
  | VAL -> "VAL"
  | VAR -> "VAR"
  | WHILE -> "WHILE"
;;

let test_tokens () =
  let open Lexer in
  let table = [ "var", "VAR", "var"; "string", "STRING", "\"test\"" ] in
  List.iter
    (fun (name, expected, input) ->
      Lexing.from_string input
      |> main
      |> print_token
      |> Alcotest.(check string) name expected)
    table
;;

let () =
  Alcotest.run
    "Parser"
    [ "parse", [ Alcotest.test_case "tokens" `Quick test_tokens ] ]
;;
