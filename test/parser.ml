module Parser = Minimal.Parser
module Lexer = Minimal.Lexer

(* Generated by menhir *)
let print_token : Parser.token -> string =
 fun _tok ->
  match _tok with
  | AMPERSAND -> "AMPERSAND"
  | AND -> "AND"
  | BAR -> "BAR"
  | BARRBRACKET -> "BARRBRACKET"
  | BEGIN -> "BEGIN"
  | CASE -> "CASE"
  | CHAR _ -> "CHAR"
  | COLON -> "COLON"
  | COLONCOLON -> "COLONCOLON"
  | COMMA -> "COMMA"
  | DO -> "DO"
  | DOT -> "DOT"
  | DOWNTO -> "DOWNTO"
  | ELSE -> "ELSE"
  | END -> "END"
  | EOF -> "EOF"
  | EQUAL -> "EQUAL"
  | EQUALEQUAL -> "EQUALEQUAL"
  | EQUALGREATER -> "EQUALGREATER"
  | FLOAT f -> "FLOAT " ^ string_of_float f
  | FN -> "FN"
  | FOR -> "FOR"
  | FUN -> "FUN"
  | HIDE -> "HIDE"
  | IDENT _ -> "IDENT"
  | IF -> "IF"
  | IN -> "IN"
  | INFIX0 _ -> "INFIX0"
  | INFIX1 _ -> "INFIX1"
  | INFIX2 _ -> "INFIX2"
  | INFIX3 _ -> "INFIX3"
  | INFIX4 _ -> "INFIX4"
  | INT i -> "INT " ^ string_of_int i
  | LBRACE -> "LBRACE"
  | LBRACKET -> "LBRACKET"
  | LBRACKETBAR -> "LBRACKETBAR"
  | LESSMINUS -> "LESSMINUS"
  | LPAREN -> "LPAREN"
  | MINUSGREATER -> "MINUSGREATER"
  | MUTABLE -> "MUTABLE"
  | OF -> "OF"
  | OR -> "OR"
  | PREFIX _ -> "PREFIX"
  | QUOTED _ -> "QUOTED"
  | RBRACE -> "RBRACE"
  | RBRACKET -> "RBRACKET"
  | RPAREN -> "RPAREN"
  | SEMI -> "SEMI"
  | STAR -> "STAR"
  | STRING s -> "STRING " ^ s
  | SUBTRACTIVE _ -> "SUBTRACTIVE"
  | THEN -> "THEN"
  | TO -> "TO"
  | TYPE -> "TYPE"
  | UNDERSCORE -> "UNDERSCORE"
  | VAL -> "VAL"
  | VAR -> "VAR"
  | WHILE -> "WHILE"
;;

let test_tokens () =
  let open Lexer in
  let success_table =
    [ "var", "VAR", "var"
    ; "string", "STRING test", "\"test\""
    ; "number", "INT 237", "237"
    ; "negative", "SUBTRACTIVE", "-237"
    ; "float", "FLOAT 23.8", "23.8"
    ]
  in
  let failure_table =
    [ ( "unterminated string"
      , Lexical_error (Unterminated_string, 0, 13)
      , "\"unterminated" )
    ; ( "unterminated comment"
      , Lexical_error (Unterminated_comment, 0, 15)
      , "(* unterminated" )
    ]
  in
  List.iter
    (fun (name, expected, input) ->
      Lexing.from_string input
      |> main
      |> print_token
      |> Alcotest.(check string) name expected)
    success_table;
  List.iter
    (fun (name, exn, input) ->
      Alcotest.check_raises name exn (fun () ->
          let _ = Lexing.from_string input |> main in
          ()))
    failure_table
;;

let () =
  Alcotest.run
    "Parser"
    [ "parse", [ Alcotest.test_case "tokens" `Quick test_tokens ] ]
;;
